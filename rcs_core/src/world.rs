use crate::errors::SimulationError;
use crate::traits::Updatable;
use crate::{Agent, Cell};
use rand::Rng;

/// Configuration for constructing a randomized world.
///
/// This struct controls:
/// - grid size (`width`, `height`)
/// - initial resource range for each cell
/// - regeneration-rate range for each cell
/// - number of agents to spawn
/// - per-agent consumption-rate range
/// - initial hit points for each agent
///
/// The world is generated by [`World::from_config`].
#[derive(Debug, Clone, Copy)]
pub struct WorldConfig {
    pub width: usize,
    pub height: usize,
    pub min_resource: u32,
    pub max_resource: u32,
    pub min_regen_rate: u32,
    pub max_regen_rate: u32,
    pub min_agents: usize,
    pub max_agents: usize,
    pub min_consumption_rate: u32,
    pub max_consumption_rate: u32,
    pub agent_hp: u32,
}

impl Default for WorldConfig {
    /// Returns a default configuration.
    ///
    /// ### Returns
    /// A [`WorldConfig`] with a 20×20 grid and moderate resource / agent ranges.
    fn default() -> Self {
        Self {
            width: 20,
            height: 20,
            min_resource: 5,
            max_resource: 20,
            min_regen_rate: 0,
            max_regen_rate: 3,
            min_agents: 1,
            max_agents: 50,
            min_consumption_rate: 1,
            max_consumption_rate: 5,
            agent_hp: 3,
        }
    }
}

/// A 2-D grid world containing cells and agents.
///
/// The world owns:
/// - a fixed `size` in cells
/// - a flat vector of [`Cell`]s
/// - a vector of [`Agent`]s
///
/// Use [`World::from_config`] to generate a random world
pub struct World {
    size: (usize, usize),
    cells: Vec<Cell>,
    agents: Vec<Agent>,
}

impl World {
    /// Creates a new world from explicit cell and agent vectors.
    ///
    /// ### Parameters
    /// - `size`: `(width, height)` pair describing the grid dimensions.
    /// - `cells`: Flat list of cells; its length should be `width * height`.
    /// - `agents`: Initial set of agents in the world.
    ///
    /// ### Returns
    /// A [`World`] instance using the provided data.
    pub fn new(size: (usize, usize), cells: Vec<Cell>, agents: Vec<Agent>) -> Self {
        Self {
            size,
            cells,
            agents,
        }
    }

    /// Returns the size of the world as `(width, height)`.
    ///
    /// ### Returns
    /// The `(width, height)` of this world.
    pub fn size(&self) -> (usize, usize) {
        self.size
    }

    /// Returns an immutable view of all cells.
    ///
    /// ### Returns
    /// A slice of all cells in row-major order.
    pub fn cells(&self) -> &[Cell] {
        &self.cells
    }

    /// Returns an immutable reference to a single cell by id.
    ///
    /// ### Parameters
    /// - `cid`: Cell id in row-major indexing.
    ///
    /// ### Returns
    /// A reference to the cell at `cid`.
    pub fn cell(&self, cid: usize) -> &Cell {
        &self.cells[cid]
    }

    /// Returns an immutable view of all agents.
    ///
    /// ### Returns
    /// A slice of all agents.
    pub fn agents(&self) -> &[Agent] {
        &self.agents
    }

    /// Constructs a randomized world from a configuration.
    ///
    /// This method:
    /// - creates a `width × height` grid of cells, each with
    ///   random starting resources and regeneration rate
    /// - spawns a random number of agents between `min_agents` and `max_agents`,
    ///   each placed at a random cell with random consumption rate
    ///
    /// Internal `assert!`s ensure configuration sanity, so invalid configs
    /// will panic during development rather than silently misbehaving.
    ///
    /// ### Parameters
    /// - `cfg`: World generation parameters.
    ///
    /// ### Returns
    /// A new [`World`] sampled according to `cfg`.
    pub fn from_config(cfg: WorldConfig) -> Self {
        assert!(cfg.width > 0 && cfg.height > 0, "world size must be > 0");
        assert!(
            cfg.min_resource <= cfg.max_resource,
            "min_resource <= max_resource"
        );
        assert!(
            cfg.min_regen_rate <= cfg.max_regen_rate,
            "min_regen_rate <= max_regen_rate"
        );
        assert!(
            cfg.min_agents > 0 && cfg.min_agents <= cfg.max_agents,
            "0 < min_agents <= max_agents"
        );
        assert!(
            cfg.min_consumption_rate <= cfg.max_consumption_rate,
            "min_consumption_rate <= max_consumption_rate"
        );

        let mut cells = Vec::with_capacity(cfg.width * cfg.height);

        let mut rng = rand::thread_rng();

        for y in 0..cfg.height {
            for x in 0..cfg.width {
                let id = y * cfg.width + x;
                let rand_resource = rng.gen_range(cfg.min_resource..=cfg.max_resource);
                let rand_regen_rate = rng.gen_range(cfg.min_regen_rate..=cfg.max_regen_rate);

                cells.push(Cell::new(
                    id,
                    rand_resource,
                    cfg.max_resource,
                    rand_regen_rate,
                    cfg.max_regen_rate,
                ));
            }
        }

        let num_agents = rng.gen_range(cfg.min_agents..=cfg.max_agents);
        let mut agents = Vec::with_capacity(num_agents);

        for id in 0..num_agents {
            let rand_x = rng.gen_range(0..cfg.width);
            let rand_y = rng.gen_range(0..cfg.height);
            let cid = rand_y * cfg.width + rand_x;
            let rand_consumption_rate =
                rng.gen_range(cfg.min_consumption_rate..=cfg.max_consumption_rate);

            agents.push(Agent::new(
                id,
                cid,
                rand_consumption_rate,
                0,
                cfg.agent_hp,
                true,
            ));
        }

        World::new((cfg.width, cfg.height), cells, agents)
    }

    /// Returns `(cell_id, resource)` pairs for all neighbors of `cid`.
    ///
    /// The neighbors are in the four cardinal directions (up, down, left, right),
    /// clipped to the bounds of the grid.
    ///
    /// ### Parameters
    /// - `cid`: Id of the central cell.
    ///
    /// ### Returns
    /// A `Vec<(cell_id, resource)>` describing the neighbors.
    fn neighbor_cells_info(&self, cid: usize) -> Vec<(usize, u32)> {
        let (width, height) = self.size;
        let x = cid % width;
        let y = cid / width;

        let mut neighbors = Vec::with_capacity(4);

        if y > 0 {
            let ny = y - 1;
            let nid = ny * width + x;
            neighbors.push((nid, self.cells[nid].cur_resource()));
        }

        if y + 1 < height {
            let ny = y + 1;
            let nid = ny * width + x;
            neighbors.push((nid, self.cells[nid].cur_resource()));
        }

        if x > 0 {
            let nx = x - 1;
            let nid = y * width + nx;
            neighbors.push((nid, self.cells[nid].cur_resource()));
        }

        if x + 1 < width {
            let nx = x + 1;
            let nid = y * width + nx;
            neighbors.push((nid, self.cells[nid].cur_resource()));
        }

        neighbors
    }

    /// Allocates resources from each cell to the agents currently on it.
    ///
    /// The algorithm:
    /// 1. Collects living agents per cell.
    /// 2. Splits the cell's current resource equally among local agents.
    /// 3. Each agent calls [`Agent::retrieve_resource`] with its share.
    /// 4. Any unused resource is returned to the cell via [`Cell::take_up_to`].
    fn allocate_resources(&mut self) {
        let mut cell_to_agents: Vec<Vec<usize>> = vec![Vec::new(); self.cells.len()];
        for (i, agent) in self.agents.iter().enumerate() {
            if !agent.is_alive() {
                continue;
            }
            let cid = agent.cid();
            cell_to_agents[cid].push(i);
        }

        for (cid, agent_indices) in cell_to_agents.iter().enumerate() {
            if agent_indices.is_empty() {
                continue;
            }

            let total = self.cells[cid].cur_resource();
            if total == 0 {
                continue;
            }

            let n = agent_indices.len() as u32;
            let base_share = total / n;
            let mut remaining = total - base_share * n;

            for &i in agent_indices {
                let leftover = self.agents[i].retrieve_resource(base_share);
                remaining += leftover;
            }
            let spent = total - remaining;
            let _ = self.cells[cid].take_up_to(spent);
        }
    }

    /// Handles side effects when an agent dies on a given cell.
    ///
    /// Currently this:
    /// - returns a fixed amount of resource to the cell
    /// - slightly boosts that cell's regeneration rate
    ///
    /// ### Parameters
    /// - `id`: Index of the dead agent in `self.agents`.
    fn handle_agent_death(&mut self, id: usize) {
        let cid = self.agents[id].cid();
        let corpse_resource: u32 = 5;
        let regen_bonus: u32 = 1;

        self.cells[cid].add_resource(corpse_resource);
        self.cells[cid].increase_rate(regen_bonus);
    }

    /// Advances a single agent by one simulation step.
    ///
    /// The logic for a living agent:
    /// - if hungry, look at neighbor cells and possibly move toward it
    /// - then call [`Agent::update`] (metabolism)
    /// - if the agent is dead after movement or metabolism, call
    ///   [`World::handle_agent_death`]
    ///
    /// Dead agents are ignored.
    ///
    /// ### Parameters
    /// - `id`: Index of the agent to update.
    fn step_agent(&mut self, id: usize) {
        if !self.agents[id].is_alive() {
            return;
        }

        if self.agents[id].is_hungry() {
            let cid = self.agents[id].cid();
            let neighbors = self.neighbor_cells_info(cid);

            if let Some(target_cid) = self.agents[id].decide_move(&neighbors) {
                let _ = self.agents[id].move_to(target_cid);
            }
        }

        if !self.agents[id].is_alive() {
            self.handle_agent_death(id);
            return;
        }

        let _ = self.agents[id].update();

        if !self.agents[id].is_alive() {
            self.handle_agent_death(id);
        }
    }

    /// Advances all agents once.
    fn step_all_agents(&mut self) {
        let len = self.agents.len();
        for id in 0..len {
            self.step_agent(id);
        }
    }
}

impl Updatable for World {
    /// Advances the entire world by one simulation step.
    ///
    /// The step order is:
    /// 1. Update all cells (resource regeneration).
    /// 2. Allocate resources from cells to agents.
    /// 3. Step each agent (movement + metabolism + death handling).
    ///
    /// ### Returns
    /// - `Ok(())` on success. At the moment this implementation never fails,
    ///   but the `Result` type allows for future error propagation.
    fn update(&mut self) -> Result<(), SimulationError> {
        for cell in &mut self.cells {
            let _ = cell.update();
        }

        self.allocate_resources();
        self.step_all_agents();

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{Agent, Cell};

    #[test]
    fn default_config_has_valid_ranges() {
        let cfg = WorldConfig::default();

        assert!(cfg.width > 0 && cfg.height > 0);
        assert!(cfg.min_resource <= cfg.max_resource);
        assert!(cfg.min_regen_rate <= cfg.max_regen_rate);
        assert!(cfg.min_agents > 0 && cfg.min_agents <= cfg.max_agents);
        assert!(cfg.min_consumption_rate <= cfg.max_consumption_rate);
    }

    #[test]
    fn from_config_creates_world_with_correct_size_and_cell_count() {
        let mut cfg = WorldConfig::default();
        cfg.width = 8;
        cfg.height = 4;
        cfg.min_agents = 3;
        cfg.max_agents = 5;

        let world = World::from_config(cfg);

        assert_eq!(world.size(), (8, 4));
        assert_eq!(world.cells().len(), 8 * 4);
        assert!(world.agents().len() >= cfg.min_agents && world.agents().len() <= cfg.max_agents);

        // All agents should be in-bounds and alive, with the configured HP.
        let (w, h) = world.size();
        let num_cells = w * h;
        for a in world.agents() {
            assert!(a.cid() < num_cells);
            assert!(a.is_alive());
            assert_eq!(a.health_point(), cfg.agent_hp);
        }

        // Cell resources are within the configured bounds.
        for c in world.cells() {
            assert!(c.cur_resource() >= cfg.min_resource && c.cur_resource() <= cfg.max_resource);
        }
    }

    #[test]
    fn neighbor_cells_info_for_center_and_edges() {
        // 3x3 grid, we only care about adjacency, not actual resources.
        let width = 3;
        let height = 3;
        let size = (width, height);

        let mut cells = Vec::new();
        for id in 0..(width * height) {
            cells.push(Cell::new(id, 0, 100, 0, 5));
        }
        let agents = Vec::<Agent>::new();
        let world = World::new(size, cells, agents);

        // Center cell (1,1) => id 4, neighbors: up(1), down(7), left(3), right(5)
        let neighbors_center = world.neighbor_cells_info(4);
        let expected_center = vec![(1, 0), (7, 0), (3, 0), (5, 0)];
        assert_eq!(neighbors_center, expected_center);

        // Top-left corner (0,0) => id 0, neighbors: down(3), right(1)
        let neighbors_corner = world.neighbor_cells_info(0);
        let expected_corner = vec![(3, 0), (1, 0)];
        assert_eq!(neighbors_corner, expected_corner);
    }

    #[test]
    fn allocate_resources_splits_evenly_and_empties_cell() {
        // One cell with 10 resource, two agents on it with consumption_rate=5.
        let cells = vec![Cell::new(0, 10, 100, 0, 10)];
        let agents = vec![
            Agent::new(0, 0, 5, 0, 5, true),
            Agent::new(1, 0, 5, 0, 5, true),
        ];
        let size = (1, 1);
        let mut world = World::new(size, cells, agents);

        world.allocate_resources();

        let cell = world.cell(0);
        assert_eq!(cell.cur_resource(), 0);

        // Each agent should have acquired enough resource to not be hungry.
        for a in world.agents() {
            assert!(!a.is_hungry());
        }
    }

    #[test]
    fn handle_agent_death_returns_resources_to_cell() {
        // Cell starts with 0 resource and 0 regen rate.
        let cells = vec![Cell::new(0, 0, 100, 0, 10)];
        // Dead or alive status doesn't matter for this function; we just use cid=0.
        let agents = vec![Agent::new(0, 0, 5, 0, 0, false)];
        let size = (1, 1);
        let mut world = World::new(size, cells, agents);

        world.handle_agent_death(0);

        // Corpse adds 5 resource and boosts regen_rate by 1.
        // After one update, we expect 5 + 1 = 6 resource.
        assert_eq!(world.cell(0).cur_resource(), 5);
        {
            let mut_cell = &mut world.cells[0];
            let _ = mut_cell.update();
        }
        assert_eq!(world.cell(0).cur_resource(), 6);
    }

    #[test]
    fn step_agent_moves_toward_richer_neighbor_and_metabolizes() {
        // Two cells in a row: [start][target with resource]
        let size = (2, 1);
        let mut cells = Vec::new();
        // cell 0: empty
        cells.push(Cell::new(0, 0, 100, 0, 10));
        // cell 1: has resource
        cells.push(Cell::new(1, 10, 100, 0, 10));

        // Single hungry agent starting at cell 0.
        let agents = vec![Agent::new(0, 0, 5, 0, 5, true)];
        let mut world = World::new(size, cells, agents);

        world.allocate_resources();
        world.step_agent(0);

        let a = &world.agents[0];

        // Agent should prefer moving to cell 1 (richer neighbor).
        assert_eq!(a.cid(), 1);
        // Movement costs 1 HP, and because agent didn’t get enough
        // food during the last allocation, HP is reduced by another 1.
        assert_eq!(a.health_point(), 3);
    }

    #[test]
    fn world_update_runs_without_error() {
        let cfg = WorldConfig::default();
        let mut world = World::from_config(cfg);

        for _ in 0..10 {
            world.update().unwrap();
        }
    }
}
